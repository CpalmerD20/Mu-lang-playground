Grammar Mu;

program     → declaration* EOF ;

* Declarations *
| variable | data | model | closure | statement ;

variable    → 'let' IDENTIFIER '=' EXPRESSION ';'
            ;
data        → '#' IDENTIFIER '=' EXPRESSION ';'
            ;
closure     → 'define' IDENTIFIER '(' PARAMETERS* ')' { BODY } ';'
            ;
model       → model IDENTIFIER ?from IDENTIFIER? '(' CONSTRUCTION_PROPERTIES* ')' { (LOCAL_PROPERTIES*) METHODS* }
            ;

* Statements *
| expression-statement | if | return | repeat | until | skip | stop | block ;

expression  → expression ';'
            ;
if          → 'if' EXPRESSION 'then' STATEMENT 'else' STATEMENT ';'
            ;
return      → 'return' EXPRESSION ';'
            ;
repeat      → 'repeat' '{' BODY '}'
            ;
until       → 'until' EXPRESSION ';'
            ;
block       → '{' DECLARATION '}'

* Expressions *
| lambda | join | match | assignment
| or | and | equality | comparison
| term| factor | unary | call | primary ;

lambda      → 'each' '(' PARAMETERS* ')' 'return' BODY ';'
            → 'each' '(" PARAMETERS* ')' '_>' BODY ';'
            ;
join        → 'join' '(' STRING STRING... ')' ';'
            ;
match       → //TODO
            ;
assignment  → ?( call '.' )? IDENTIFIER '=' ASSIGNMENT | logic_or //TODO change from Lox, don't want mutation on certain data structures
            ;
logic_or    → logic_and ( 'or' logic_and )*
            ;
equality    → comparison (( '!=' | '==' ) comparison )*
            ;
comparison 	→ term ( ( > | >= | < | <= ) term )*
            ;
term       	→ factor ( ( - | + ) factor )*
            ;
factor     	→ unary ( ( / | * | ^* ) unary )*
            ;
unary      	→ ( "!" | "-" ) unary | call
            ;
call       	→ primary ( "(" arguments? ")" | "." IDENTIFIER )*
            ;
primary    	→ "true" | "false" | "void" | "self"
            | NUMBER | STRING | IDENTIFIER | "(" expression ")"

* Lexical *
NUMBER     	→ DIGIT+ ( "." DIGIT+ )? ;
STRING     	→ "\"" <any char except "\"">* "\"" ;
IDENTIFIER 	→ ALPHA ( ALPHA | DIGIT )* ;
ALPHA      	→ "a" ... "z" | "A" ... "Z" | "_" ;
DIGIT      	→ "0" ... "9" ;